[{"short": "Tea", "name": "Tea", "text": "<p>Complex UI framework based on jQuery. </p>\n<p>Copyright (c) 2012 Brantley Harris. All rights reserved. </p>\n", "important": false, "sig": "", "type": "class", "children": [{"short": "Button", "name": "Tea.Button", "text": "<p>Click on me! </p>\n", "important": false, "sig": "", "type": "class", "children": []}, {"short": "Container", "name": "Tea.Container", "text": "<p>An element that contains other elements. </p>\n", "requires": ["Tea.Element"], "important": false, "sig": "", "type": "class", "children": []}, {"short": "Element", "name": "Tea.Element", "text": "<p>Copyright (c) 2012 Brantley Harris. All rights reserved. </p>\n", "important": false, "sig": "", "type": "class", "children": []}, {"short": "Object", "name": "Tea.Object", "text": "<p>Base object that allows class/subclass behavior, events, and a regard         for \"options\". </p>\n<p>        Mamal = Tea.Class({type: 'Mamal'});         Human = Mamal.extend({type: 'Mamal'});         Bob = Human({name: 'Bob'}); </p>\n", "important": false, "sig": "", "type": "class", "children": [{"short": "bind", "name": "Tea.Object.bind", "text": "<p>Binds an event for this instance to the given function which will be  called with the given args. </p>\n<p>event:     An event name to bind. </p>\n<p>handler:     The function to call when the event is triggered. </p>\n<p>args (optional):     A list of arguments to pass into when calling the handler. </p>\n", "important": false, "sig": "(event, handler, [args])", "type": "function", "children": []}, {"short": "destroy", "name": "Tea.Object.prototype.destroy", "text": "<p>Destroys the object and unhooks all events. </p>\n", "important": false, "sig": "()", "type": "function", "children": []}, {"short": "hook", "name": "Tea.Object.hook", "text": "<p>Binds onto the target, but does so in a manner that allows this object to track its \"hooks\".  One can then unhook(target), or unhookAll() to release the bind.  This is beneficial from a memory standpoint, as hooks won't leak like a bind will. </p>\n<p>target:     The target to bind onto. </p>\n<p>event:     An event name to bind. </p>\n<p>handler:     The function to call when the event is triggered. </p>\n<p>args (optional):     A list of arguments to pass into when calling the handler. </p>\n", "important": false, "sig": "(target, event, handler, [args])", "type": "function", "children": []}, {"short": "init", "name": "Tea.Object.init", "text": "<p>Override this to change initialization code. </p>\n<p>Note: Not called on class prototypes. </p>\n", "important": false, "sig": "(options)", "type": "function", "children": []}, {"short": "toString", "name": "Tea.Object.toString", "text": "<p>Returns a string representation of the object. </p>\n", "important": false, "sig": "()", "type": "function", "children": []}, {"short": "trigger", "name": "Tea.Object.prototype.trigger", "text": "<p>event:             The event name to trigger. </p>\n<p>        args:             Arguments to pass onto the function.  These go after             any arguments set in the bind(). </p>\n", "important": false, "sig": "(name)", "type": "function", "children": []}, {"short": "unbind", "name": "Tea.Object.prototype.unbind", "text": "<p>Unbinds an events from this instance.  If a handler is given, only  events pointing to that handler are unbound.  Otherwise all handlers  for that event are unbound. </p>\n<p>event:     An event name to unbind. </p>\n<p>handler:     Only events pointing the given handler are unbound. </p>\n", "important": false, "sig": "(event, [handler])", "type": "function", "children": []}, {"short": "unhook", "name": "Tea.Object.unhook", "text": "<p>Unhooks all binds on target. </p>\n<p>target:     The target to release all binds from. </p>\n", "important": false, "sig": "(target)", "type": "function", "children": []}, {"short": "unhookAll", "name": "Tea.Object.unhookAll", "text": "<p>Unhooks all binds on all targets. </p>\n", "important": false, "sig": "()", "type": "function", "children": []}]}, {"short": "Stack", "name": "Tea.Stack", "text": "<p>A container that acts as a stack, you can push and pop onto it. </p>\n<p>    The default skin pushes elements onto it from the right to the left, so     that you only see the top few elements that can fit on the screen. </p>\n", "important": false, "sig": "", "type": "class", "extends": ["Tea.Container"], "requires": ["Tea.Container"], "children": [{"short": "pop", "name": "Tea.Stack.pop", "text": "<p>Pops the top item off the stack. </p>\n<p>If *item* is specified, it will pop that item and all after it. </p>\n", "important": false, "sig": "( [item] )", "type": "function", "children": []}, {"short": "push", "name": "Tea.Stack.push", "text": "<p>Pushes the *item* onto the stack. </p>\n<p>If *after* is specified, all items after it will be popped before pushing the *item*. </p>\n", "important": false, "sig": "(item, [after])", "type": "function", "children": []}]}, {"short": "Testing", "name": "Tea.Testing", "text": "<p>A testing framework. </p>\n", "requires": ["Tea"], "important": false, "sig": "", "type": "module", "children": []}, {"short": "Tree", "name": "Tea.Tree", "text": "<p>A Tree item, buttons with containers on the back. </p>\n", "important": false, "sig": "", "extends": ["Tea.Button"], "type": "class", "children": []}, {"short": "create", "name": "Tea.create", "text": "<p>Returns an object created using the <tt>options</tt>, which can be an object  or a string. </p>\n<p>If <tt>options</tt> is a string, a type returned by <tt>Tea.getType()</tt> will  be returned, unless it can't find the type, then it is treated as a  jQuery object. </p>\n<p>If <img src=\"options\" alt=\"options\"> is a jQuery object it is wrapped as the source of a  Tea.Element and returned. </p>\n<p>If <tt>options</tt> is an <tt>Object</tt>, the <tt>.type</tt> attribute will be used to look up the correct type and will be used to create an instance of that type. </p>\n<p>If <tt>options</tt> is an instance of a <tt>Tea.Object</tt>, it will be returned unaffected. </p>\n", "important": false, "sig": "(options)", "type": "function", "children": []}, {"short": "generateUniqueID", "name": "Tea.generateUniqueID", "text": "<p>Generates a unique id with the given <tt>prefix</tt>. </p>\n", "important": false, "sig": "(prefix)", "type": "function", "children": []}, {"short": "getType", "name": "Tea.getType", "text": "<p>Returns the object registered with the given <tt>name</tt>. </p>\n", "important": false, "sig": "(name)", "type": "function", "children": []}, {"short": "latent", "name": "Tea.latent", "text": "<p>Calls the given function <tt>func</tt> after the given <tt>milliseconds</tt> with a <tt>this</tt> of <tt>context</tt>. </p>\n<p>The function returned is a wrapper function.  When it is called, it waits  for the specified <tt>milliseconds</tt> before actually being run.  Also, if it is waiting to run, and is called again, it will refresh its timer. This is great for things like auto-complete, where you want to cancel and refresh the timer every time a key is hit </p>\n<p>You can easily bind a latent to an event, the following code will run  the method \"onKeyup\" on \"this\" 300 milliseconds after the last keyup event  of a series: </p>\n<p><tt>$(window).keyup( Tea.latent(this.onKeyup, 300, this) )</tt> </p>\n<p>The function returned also provides a few extra methods on the function, itself: </p>\n<p><tt>.cancel()</tt> - Cancels the timer. </p>\n<p><tt>.refresh([milliseconds])</tt> - Refreshes the timer, and optionally resets the <tt>milliseconds</tt>. </p>\n<p>Example: </p>\n<div class='code'>function&nbsp;hello()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;this.log(\"Hello&nbsp;World!\");<br/>}<br/><br/>hello&nbsp;=&nbsp;latent(hello,&nbsp;console,&nbsp;1000);<br/>hello();<br/>hello();<br/>hello();<br/><br/>//&nbsp;After&nbsp;1&nbsp;second:&nbsp;\"Hello&nbsp;World!\"<br/><br/>hello();<br/>hello.cancel();<br/><br/>//&nbsp;Nothing...<br/><br/>hello.refresh(1000);<br/><br/>//&nbsp;After&nbsp;1&nbsp;second:&nbsp;\"Hello&nbsp;World!\"<br/><br/>hello();<br/><br/>//&nbsp;After&nbsp;1&nbsp;second:&nbsp;\"Hello&nbsp;World!\"</div>", "important": false, "sig": "(func, milliseconds, context)", "type": "function", "children": []}, {"short": "overrideMethod", "name": "Tea.overrideMethod", "text": "<p>Creates a callback that when run, provides a <tt>__super__</tt> on *this* which points to  <tt>super_function</tt>, and then runs <tt>func</tt>.  A great way to do inheritance. </p>\n", "important": false, "sig": "(super_function, function)", "type": "function", "children": []}, {"short": "registerType", "name": "Tea.registerType", "text": "<p>Registeres an <tt>object</tt> as a type with the given <tt>name</tt>. </p>\n<p>name:     Name of the type. </p>\n<p>object:     The object. </p>\n", "important": false, "sig": "(name, object)", "type": "function", "children": []}, {"short": "require", "name": "Tea.require", "text": "<p>Imports the given arguments by appending &lt;script&gt; or &lt;style&gt; tags to the head. Note: Importing is done relative to the page we're on, not the script. Note: The required script is loaded sometime AFTER the requiring script, so you can't use       the provided namespace (functions and variables) right away. </p>\n<p>arguments:     Strings of urls to the given resource.  If the string ends with .css, it is added with     a &lt;style&gt; tag; if it's a .js, it is added with a &lt;script&gt; tag. </p>\n", "important": false, "sig": "(...)", "type": "function", "children": []}]}]